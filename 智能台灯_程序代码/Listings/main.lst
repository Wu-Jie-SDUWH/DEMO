C51 COMPILER V9.59.0.0   MAIN                                                              10/13/2019 19:21:56 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: G:\KEIL\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.ls
                    -t) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          
   4          #define uchar unsigned char   
   5          #define uint  unsigned int    
   6          
   7          sbit LED     = P1^0;      // 模式指示灯，亮是自动模式，灭是手动模式
   8          sbit Light   = P1^4;      // 台灯控制引脚
   9          sbit Key1    = P1^1;      // 按键1，模式切换按键
  10          sbit Key2    = P1^2;      // 按键2，亮度减少按键      
  11          sbit Key3    = P1^3;      // 按键3，亮度增加按键
  12          sbit Ceju    = P1^5;      // 红外测距模块
  13          sbit Beep    = P1^6;      // 蜂鸣器模块
  14          /*********************************************************/
  15          // 因焊接时P20引脚损坏，故焊接及编程中P2引脚处的连接依次上移一位，与原理图中不再一致，需注意！！！
  16          /*********************************************************/
  17          sbit ADC_CS  = P2^4;      // ADC0832的CS引脚  
  18          sbit ADC_CLK = P2^1;      // ADC0832的CLK引脚
  19          sbit ADC_DAT = P2^2;      // ADC0832的DI/DO引脚
  20          sbit HC      = P2^3;      // 人体红外检测模块
  21          
  22          
  23          uchar gCount=0;       // 全局计数变量
  24          uchar gIndex;         // 亮度变量，0是最暗，9是最亮，一共10档
  25          uint  gTime=0;        // 计时变量，用于计时多久没检测到有人
  26          
  27          /*********************************************************/
  28          // 毫秒级的延时函数，time是要延时的毫秒数
  29          /*********************************************************/
  30          void Delay(uint time)
  31          {
  32   1        uint i,j;
  33   1        for(i=0;i<time;i++)
  34   1          for(j=0;j<112;j++);
  35   1      }
  36          
  37          /*********************************************************/
  38          // ADC0832的时钟脉冲
  39          /*********************************************************/
  40          void WavePlus()
  41          {
  42   1        _nop_();
  43   1        ADC_CLK = 1;
  44   1        _nop_();
  45   1        ADC_CLK = 0;
  46   1      }
  47          
  48          
  49          /*********************************************************/
  50          // 获取指定通道的A/D转换结果
  51          /*********************************************************/
  52          uchar Get_ADC0832()
  53          { 
  54   1        uchar i;
C51 COMPILER V9.59.0.0   MAIN                                                              10/13/2019 19:21:56 PAGE 2   

  55   1        uchar dat1=0;
  56   1        uchar dat2=0;
  57   1        ADC_CLK = 0;      // 电平初始化
  58   1        ADC_DAT = 1;
  59   1        _nop_();
  60   1        ADC_CS = 0;
  61   1        WavePlus();     // 起始信号 
  62   1        ADC_DAT = 1;
  63   1        WavePlus();     // 通道选择的第一位
  64   1        ADC_DAT = 0;      
  65   1        WavePlus();     // 通道选择的第二位
  66   1        ADC_DAT = 1;
  67   1        for(i=0;i<8;i++)    // 第一次读取
  68   1        {
  69   2          dat1<<=1;
  70   2          WavePlus();
  71   2          if(ADC_DAT)
  72   2            dat1=dat1|0x01;
  73   2          else
  74   2            dat1=dat1|0x00;
  75   2        }
  76   1        for(i=0;i<8;i++)    // 第二次读取
  77   1        {
  78   2          dat2>>= 1;
  79   2          if(ADC_DAT)
  80   2            dat2=dat2|0x80;
  81   2          else
  82   2            dat2=dat2|0x00;
  83   2          WavePlus();
  84   2        }
  85   1        _nop_();        // 结束此次传输
  86   1        ADC_DAT = 1;
  87   1        ADC_CLK = 1;
  88   1        ADC_CS  = 1;   
  89   1      
  90   1        if(dat1==dat2)      // 返回采集结果
  91   1          return dat1;
  92   1        else
  93   1          return 0;
  94   1      } 
  95          
  96          /*********************************************************/
  97          // 定时器初始化
  98          /*********************************************************/
  99          void TimerInit()
 100          {
 101   1        TMOD = 0x01;      // 使用定时器0，工作方式1  
 102   1        TH0  = 252;     // 给定时器0的TH0装初值
 103   1        TL0  = 24;      // 给定时器0的TL0装初值 
 104   1        ET0  = 1;       // 定时器0中断使能
 105   1        EA   = 1;     // 打开总中断
 106   1        TR0  = 1;       // 启动定时器0
 107   1      }
 108          
 109          /*********************************************************/
 110          // 手动控制
 111          /*********************************************************/
 112          void ManualControl()
 113          {
 114   1        // 亮度减少
 115   1        if(Key2==0)       // 如果按键2被按下去
 116   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              10/13/2019 19:21:56 PAGE 3   

 117   2          if(gIndex>0)      // 只要当前亮度不为最低才能减少亮度
 118   2          {
 119   3            gIndex--;     // 亮度降低一档
 120   3            Delay(300);   // 延时0.3秒
 121   3          }
 122   2        }
 123   1        // 亮度增加
 124   1        if(Key3==0)       // 如果按键3被按下去
 125   1        {
 126   2          if(gIndex<9)      // 只要当前亮度不为最高才能增加亮度
 127   2          {
 128   3            gIndex++;     // 亮度增加一档
 129   3            Delay(300);   // 延时0.3秒
 130   3          }
 131   2        }
 132   1      }
 133          
 134          
 135          
 136          
 137          /*********************************************************/
 138          // 自动控制
 139          /*********************************************************/
 140          void AutoControl(uchar num)
 141          {
 142   1        if(num<59)            // 最亮
 143   1          gIndex=9;
 144   1        else if((num>65)&&(num<81))   // 第二亮
 145   1          gIndex=8;
 146   1        else if((num>87)&&(num<103))    // 第三亮
 147   1          gIndex=7;
 148   1        else if((num>109)&&(num<125))
 149   1          gIndex=6;
 150   1        else if((num>131)&&(num<147))
 151   1          gIndex=5;
 152   1        else if((num>153)&&(num<169))
 153   1          gIndex=4;
 154   1        else if((num>175)&&(num<191))
 155   1          gIndex=3;
 156   1        else if((num>197)&&(num<213))
 157   1          gIndex=2;
 158   1        else if((num>219)&&(num<235))
 159   1          gIndex=1;
 160   1        else if(num>241)           // 最暗
 161   1          gIndex=0;
 162   1      }
 163          
 164          
 165          /*********************************************************/
 166          // 蜂鸣器报警判断
 167          /*********************************************************/
 168          void AlarmJudge()
 169          {
 170   1        if(Ceju==0)       // 距离是否过近
 171   1        {
 172   2          Beep=0;       // 是的话启动蜂鸣器
 173   2        }
 174   1        else
 175   1        {
 176   2          Beep=1;       // 否的话关闭蜂鸣器
 177   2        }
 178   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              10/13/2019 19:21:56 PAGE 4   

 179          
 180          
 181          /*********************************************************/
 182          // 主函数
 183          /*********************************************************/
 184          void main()
 185          {
 186   1        uchar ret;
 187   1        
 188   1        TimerInit();        // 定时器初始化
 189   1        LED=0;          // 指示灯点亮(自动模式指示灯)
 190   1        ret=Get_ADC0832();    // 获取AD采集结果(环境光照强度)
 191   1        AutoControl(ret);     // 上电先进行一次自动亮度控制 
 192   1        AutoControl(ret+7);
 193   1        
 194   1        while(1)
 195   1        {
 196   2          /* 模式切换控制 */
 197   2          if(Key1==0)         // 如果按键1被按下去
 198   2          {
 199   3            LED=~LED;       // 切换LED灯状态
 200   3            if(LED==0)        // 如果切换后是自动模式的话
 201   3            {
 202   4              ret=Get_ADC0832();  // 获取AD采集结果(环境光照强度)
 203   4              AutoControl(ret);   // 进行一次自动亮度调整
 204   4              AutoControl(ret+7);
 205   4            }
 206   3            Delay(10);        // 延时消除按键按下的抖动
 207   3            while(!Key1);       // 等待按键释放
 208   3            Delay(10);        // 延时消除按键松开的抖动
 209   3          }
 210   2            
 211   2          /* 亮度控制 */
 212   2          if(LED==1)          // 如果LED是灭的
 213   2          {
 214   3            ManualControl();      // 则进行手动控制
 215   3          }
 216   2          else              // 如果LED是亮的
 217   2          {
 218   3            if(gTime<60000)     // 如果最近60秒内检测到有人
 219   3            {
 220   4              ret=Get_ADC0832();  // 获取AD采集结果(环境光照强度)
 221   4              AutoControl(ret);   // 进行自动控制 
 222   4              AutoControl(ret+7);
 223   4              Delay(200);
 224   4            }
 225   3          }
 226   2          
 227   2          /*检测是否有人*/
 228   2          if(HC==1)
 229   2          {
 230   3            gTime=0;          // 检测到有人，则把60秒计时清零
 231   3          }
 232   2          if(gTime>60000)       // 如果gTime的值超过了60000
 233   2          {
 234   3            gTime=60000;        // 把gTime的值重新赋值为60000，避免过大溢出
 235   3            gIndex=0;         // 如果60秒检测不到有人，则把台灯熄灭
 236   3          }
 237   2      
 238   2      /* 蜂鸣器报警判断 */
 239   2          AlarmJudge();
 240   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              10/13/2019 19:21:56 PAGE 5   

 241   1      }
 242          
 243          /*********************************************************/
 244          // 定时器0服务程序，1毫秒
 245          /*********************************************************/
 246          void Timer0(void) interrupt 1
 247          {
 248   1        TH0  = 252;           // 给定时器0的TH0装初值
 249   1        TL0  = 24;            // 给定时器0的TL0装初值 
 250   1        
 251   1        if(LED==0)
 252   1        {
 253   2          gTime++;            // 自动模式下，每1毫秒gTime变量加1
 254   2        } 
 255   1        gCount++;           // 每1毫秒，gCount变量加1
 256   1        if(gCount==10)          // 如果gCount加到10了
 257   1        {
 258   2          gCount=0;         // 则将gCount清零，进入新一轮的计数
 259   2          if(gIndex!=0)         // 如果说台灯不是最暗的(熄灭)
 260   2          {
 261   3            Light=0;          // 则把台灯点亮
 262   3          }
 263   2        }
 264   1      
 265   1        if(gCount==gIndex)          // 如果gCount计数到和gIndex一样了
 266   1        {
 267   2          if(gIndex!=9)         // 如果说台灯不是最亮的
 268   2          {
 269   3            Light=1;          // 则把台灯熄灭
 270   3          }
 271   2        }
 272   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    625    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
